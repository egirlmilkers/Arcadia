import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:arcadia/main.dart';
import 'package:arcadia/services/logging.dart';
import 'package:mime/mime.dart';
import 'package:pointycastle/export.dart';
import 'package:pointycastle/pointycastle.dart';
import 'package:http/http.dart' as http;

/// Mostly taken from SillyTavern
class VertexAPI {
  static Future<Map<String, dynamic>> getVertexAIAuth(String apiKey) async {
    try {
      final dynamic serviceAccount = jsonDecode(apiKey);
      final jwtToken = await generateJWTToken(serviceAccount);
      final accessToken = await getAccessToken(jwtToken);
      return {'authHeader': 'Bearer $accessToken', 'authType': 'full'};
    } catch (e) {
      ArcadiaLog().error('Failed to authenticate with service account:', e);
      throw Exception('Vertex service account authentication failed: $e');
    }
  }

  /// Generates a JWT token for Google Cloud authentication using service account credentials.
  ///
  /// [serviceAccount] - Service account JSON object (typically parsed from JSON file)
  /// Returns a JWT token string
  static Future<String> generateJWTToken(Map<String, dynamic> serviceAccount) async {
    final now = (DateTime.now().millisecondsSinceEpoch / 1000).floor();
    final expiry = now + 3600;

    final header = {'alg': 'RS256', 'typ': 'JWT'};

    final payload = {
      'iss': serviceAccount['client_email'],
      'scope': 'https://www.googleapis.com/auth/cloud-platform',
      'aud': 'https://oauth2.googleapis.com/token',
      'iat': now,
      'exp': expiry,
    };

    // json and base64url encode the header and payload
    final headerBase64 = base64Url.encode(utf8.encode(jsonEncode(header)));
    final payloadBase64 = base64Url.encode(utf8.encode(jsonEncode(payload)));
    final signatureInput = '$headerBase64.$payloadBase64';

    // Create signature using private key
    final privateKeyString = serviceAccount['private_key'];
    final signature = _signRS256(signatureInput, privateKeyString);
    final signatureBase64 = base64Url.encode(signature);

    return '$signatureInput.$signatureBase64';
  }

  /// Exchanges a JWT token for a Google Cloud access token
  ///
  /// [jwtToken] - The JWT token generated by generateJWTToken
  /// Returns the access token string
  static Future<dynamic> getAccessToken(String jwtToken) async {
    final response = await http.post(
      Uri.parse('https://oauth2.googleapis.com/token'),
      headers: {'Content-Type': 'application/x-www-form-urlencoded'},
      body: {'grant_type': 'urn:ietf:params:oauth:grant-type:jwt-bearer', 'assertion': jwtToken},
    );

    if (response.statusCode != 200) {
      throw Exception('Failed to get access token: ${response.body}');
    }

    final data = jsonDecode(response.body);
    return data['access_token'];
  }

  static Future<Map<String, dynamic>> getBody(List<ChatMessage> history) async {
    return <String, dynamic>{
      'instances': [
        {
          // Your existing 'contents' logic goes inside the instance object
          'contents': await Future.wait(
            history.map((message) async {
              final parts = <Map<String, dynamic>>[];
              parts.add({'text': message.text});

              // Handle attachments if your tuned model supports them
              if (message.attachments.isNotEmpty) {
                for (final attachmentPath in message.attachments) {
                  try {
                    final file = File(attachmentPath);
                    final mimeType = lookupMimeType(attachmentPath);
                    if (mimeType != null) {
                      final bytes = await file.readAsBytes();
                      final base64String = base64Encode(bytes);
                      parts.add({
                        'inlineData': {'mimeType': mimeType, 'data': base64String},
                      });
                    }
                  } catch (e) {
                    // Logs an error if an attachment cannot be processed.
                    ArcadiaLog().error('Error processing attachment: $attachmentPath', e);
                  }
                }
              }
              return {'role': message.isUser ? 'user' : 'model', 'parts': parts};
            }),
          ),
        },
      ],
    };
  }
}

/// Signs data using RS256 (RSA with SHA-256)
Uint8List _signRS256(String data, String privateKeyPem) {
  // Parse the PEM private key
  final privateKey = _parsePrivateKeyFromPem(privateKeyPem);

  // Create signer
  final signer = RSASigner(SHA256Digest(), '0609608648016503040201');

  // Initialize the signer with the private key
  signer.init(true, PrivateKeyParameter<RSAPrivateKey>(privateKey));

  // Sign the data
  final signature = signer.generateSignature(utf8.encode(data));

  return signature.bytes;
}

/// Parses an RSA private key from PEM format
RSAPrivateKey _parsePrivateKeyFromPem(String pem) {
  // Remove PEM headers/footers and decode base64
  final lines = pem.split('\n').where((line) => !line.startsWith('-----')).join('');
  final keyBytes = base64.decode(lines);

  // Parse the ASN.1 structure
  final asn1Parser = ASN1Parser(keyBytes);
  final sequence = asn1Parser.nextObject() as ASN1Sequence;

  // PKCS#1 format check
  if (sequence.elements!.length == 9) {
    // Traditional RSA private key format
    final modulus = (sequence.elements![1] as ASN1Integer).integer!;
    final privateExponent = (sequence.elements![3] as ASN1Integer).integer!;
    final p = (sequence.elements![4] as ASN1Integer).integer!;
    final q = (sequence.elements![5] as ASN1Integer).integer!;

    return RSAPrivateKey(modulus, privateExponent, p, q);
  }
  // PKCS#8 format
  else if (sequence.elements!.length == 3) {
    // PKCS#8 private key format
    final privateKeyOctet = sequence.elements![2] as ASN1OctetString;
    final privateKeyParser = ASN1Parser(privateKeyOctet.octets);
    final privateKeySequence = privateKeyParser.nextObject() as ASN1Sequence;

    final modulus = (privateKeySequence.elements![1] as ASN1Integer).integer!;
    final privateExponent = (privateKeySequence.elements![3] as ASN1Integer).integer!;
    final p = (privateKeySequence.elements![4] as ASN1Integer).integer!;
    final q = (privateKeySequence.elements![5] as ASN1Integer).integer!;

    return RSAPrivateKey(modulus, privateExponent, p, q);
  } else {
    throw ArgumentError('Invalid private key format');
  }
}
